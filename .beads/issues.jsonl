{"id":"rrrlz-0p3","title":"Implement RRT (Rapidly-exploring Random Tree) pathfinding","description":"Sampling-based planner from robotics. Randomly samples points in configuration space, extends tree toward samples. Uses floating-point distance calculations, random number generation. LLVM interest: floating-point heavy (sqrt, distance), RNG, nearest-neighbor search, dynamic tree growth. Very different optimization profile from grid-based algos.","status":"open","priority":4,"issue_type":"feature","created_at":"2026-02-13T22:26:44.043143177-05:00","created_by":"phiat","updated_at":"2026-02-13T22:26:44.043143177-05:00"}
{"id":"rrrlz-1lw","title":"Implement D* Lite (dynamic replanning)","description":"Incrementally repairs shortest paths when the graph changes (e.g., new obstacles discovered). Used in robotics (Mars rovers). More complex state management than A*. LLVM interest: priority queue with key pairs, incremental updates, complex state transitions.","status":"open","priority":4,"issue_type":"feature","created_at":"2026-02-13T22:26:39.569702266-05:00","created_by":"phiat","updated_at":"2026-02-13T22:26:39.569702266-05:00"}
{"id":"rrrlz-6ox","title":"Implement hex grid A* pathfinding (cube coordinates, 6-dir)","description":"A* on a hexagonal grid using cube coordinates (q,r,s where q+r+s=0). 6 neighbor directions instead of 4. Cube distance heuristic: max(abs(dq),abs(dr),abs(ds)). Rich optimization targets: coordinate conversion helpers, 6-way neighbor loop, heuristic with abs/max. Ref: redblobgames.com/grids/hexagons/","status":"open","priority":2,"issue_type":"feature","created_at":"2026-02-13T22:26:20.895841582-05:00","created_by":"phiat","updated_at":"2026-02-13T22:26:20.895841582-05:00"}
{"id":"rrrlz-7x4","title":"Implement Floyd-Warshall all-pairs shortest paths","description":"Floyd-Warshall computes shortest paths between ALL pairs of vertices. O(V^3) with clean triple-nested loop: d[i][j] = min(d[i][j], d[i][k]+d[k][j]). Excellent LLVM target: tight triple loop is prime for loop unrolling, vectorization at O3, cache optimization differences. Simple code, rich optimization surface.","status":"open","priority":3,"issue_type":"feature","created_at":"2026-02-13T22:26:26.500414886-05:00","created_by":"phiat","updated_at":"2026-02-13T22:26:26.500414886-05:00"}
{"id":"rrrlz-98t","title":"Implement IDA* (Iterative Deepening A*)","description":"Memory-efficient A* variant using depth-first search with f-cost threshold. Space: O(d) vs A*'s exponential. Each iteration does cost-bounded DFS, increasing threshold to minimum f-cost that exceeded previous bound. Good LLVM target: recursive DFS, stack-based iteration, threshold comparisons. Interesting contrast to heap-based approaches.","status":"open","priority":3,"issue_type":"feature","created_at":"2026-02-13T22:26:31.494024644-05:00","created_by":"phiat","updated_at":"2026-02-13T22:26:31.494024644-05:00"}
{"id":"rrrlz-99l","title":"Implement Ant Colony Optimization pathfinding","description":"Bio-inspired: simulated ants deposit pheromones on paths, reinforcing good solutions over iterations. Probabilistic path selection based on pheromone intensity + distance heuristic. LLVM interest: heavy floating-point (pheromone decay, probability), randomness, iterative convergence loops, 2D pheromone matrix updates.","status":"open","priority":4,"issue_type":"feature","created_at":"2026-02-13T22:26:45.777057702-05:00","created_by":"phiat","updated_at":"2026-02-13T22:26:45.777057702-05:00"}
{"id":"rrrlz-9x5","title":"Implement flow field pathfinding","description":"Precomputes a vector field directing any position toward a goal. Three phases: cost field, integration field (modified Dijkstra), flow field generation. Used in RTS games (Supreme Commander 2). Great LLVM target: three distinct grid-processing passes, each with different access patterns. Heavy array manipulation.","status":"open","priority":3,"issue_type":"feature","created_at":"2026-02-13T22:26:37.559372905-05:00","created_by":"phiat","updated_at":"2026-02-13T22:26:37.559372905-05:00"}
{"id":"rrrlz-ear","title":"Implement Jump Point Search (JPS) on square grid","description":"JPS prunes symmetric paths in uniform-cost grids by jumping over intermediate nodes. Only expands 'jump points' where direction changes are forced. Same optimality as A* but explores far fewer nodes. Great LLVM target: heavy branching for direction-specific pruning rules, recursive jump functions, forced neighbor detection.","status":"open","priority":2,"issue_type":"feature","created_at":"2026-02-13T22:26:22.37310353-05:00","created_by":"phiat","updated_at":"2026-02-13T22:26:22.37310353-05:00"}
{"id":"rrrlz-iu0","title":"Implement Bellman-Ford shortest path (negative weights)","description":"Bellman-Ford relaxes all edges V-1 times to handle negative edge weights. O(V*E) time. Interesting for LLVM: triple nested loops, edge list iteration, negative cycle detection pass. Different optimization profile from heap-based algorithms - more loop-heavy, less branching.","status":"open","priority":2,"issue_type":"feature","created_at":"2026-02-13T22:26:23.959392165-05:00","created_by":"phiat","updated_at":"2026-02-13T22:26:23.959392165-05:00"}
{"id":"rrrlz-jxy","title":"Implement bidirectional A* search","description":"Runs two A* searches simultaneously - forward from start, backward from goal - meeting in the middle. O(b^(d/2)) vs O(b^d). Implementation: two open sets, two closed sets, meeting detection. Good LLVM target: duplicated search logic, interleaved expansion, complex termination condition.","status":"open","priority":3,"issue_type":"feature","created_at":"2026-02-13T22:26:28.461506005-05:00","created_by":"phiat","updated_at":"2026-02-13T22:26:28.461506005-05:00"}
