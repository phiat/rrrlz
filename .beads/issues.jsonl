{"id":"rrrlz-0p3","title":"Implement RRT (Rapidly-exploring Random Tree) pathfinding","description":"Sampling-based planner from robotics. Randomly samples points in configuration space, extends tree toward samples. Uses floating-point distance calculations, random number generation. LLVM interest: floating-point heavy (sqrt, distance), RNG, nearest-neighbor search, dynamic tree growth. Very different optimization profile from grid-based algos.","status":"open","priority":4,"issue_type":"feature","created_at":"2026-02-13T22:26:44.043143177-05:00","created_by":"phiat","updated_at":"2026-02-13T22:26:44.043143177-05:00"}
{"id":"rrrlz-1lw","title":"Implement D* Lite (dynamic replanning)","description":"Incrementally repairs shortest paths when the graph changes (e.g., new obstacles discovered). Used in robotics (Mars rovers). More complex state management than A*. LLVM interest: priority queue with key pairs, incremental updates, complex state transitions.","status":"open","priority":4,"issue_type":"feature","created_at":"2026-02-13T22:26:39.569702266-05:00","created_by":"phiat","updated_at":"2026-02-13T22:26:39.569702266-05:00"}
{"id":"rrrlz-1uc","title":"Evaluate shared utility header for common grid operations","description":"Review after 3+ algos are implemented: assess whether a shared grid_common.h (is_valid, get_index, grid printing, path reconstruction) is worth it. Trade-off: shared code is DRY but changes the per-file LLVM IR story (cross-TU inlining, LTO). May want both: self-contained versions for IR study + shared version for the visualizer. Blocked until hex A*, JPS, and Bellman-Ford are done.","status":"open","priority":3,"issue_type":"task","owner":"phiat99@gmail.com","created_at":"2026-02-13T22:33:54.359884113-05:00","created_by":"phiat","updated_at":"2026-02-13T22:33:54.359884113-05:00","dependencies":[{"issue_id":"rrrlz-1uc","depends_on_id":"rrrlz-6ox","type":"blocks","created_at":"2026-02-13T22:34:02.79555915-05:00","created_by":"phiat"},{"issue_id":"rrrlz-1uc","depends_on_id":"rrrlz-ear","type":"blocks","created_at":"2026-02-13T22:34:02.827533763-05:00","created_by":"phiat"},{"issue_id":"rrrlz-1uc","depends_on_id":"rrrlz-iu0","type":"blocks","created_at":"2026-02-13T22:34:02.858456886-05:00","created_by":"phiat"}]}
{"id":"rrrlz-5dy","title":"Add edge relaxation counter, BF full-pass stepping, and benchmark mode","status":"closed","priority":2,"issue_type":"feature","owner":"phiat99@gmail.com","created_at":"2026-02-14T11:35:30.424263593-05:00","created_by":"phiat","updated_at":"2026-02-14T11:35:34.564232345-05:00","closed_at":"2026-02-14T11:35:34.564232345-05:00","close_reason":"Implemented in a0a2a57: relaxations metric in AlgoVis, BF full-pass-per-step, B key benchmark mode with comparison table"}
{"id":"rrrlz-6f6","title":"Create shared map library with larger/complex grids","description":"Create maps/ directory with multiple grid maps as .h files (or loadable format). Include: current 20x20, a 50x50 with corridors, a 100x100 maze, an open map with sparse obstacles, and a dense labyrinth. Each algo can #include the map. Also add a simple map generator (procedural maze via recursive backtracker or similar). These larger maps will stress-test optimization differences more visibly.","status":"open","priority":2,"issue_type":"task","owner":"phiat99@gmail.com","created_at":"2026-02-13T22:33:50.934137894-05:00","created_by":"phiat","updated_at":"2026-02-13T22:33:50.934137894-05:00"}
{"id":"rrrlz-6ox","title":"Implement hex grid A* pathfinding (cube coordinates, 6-dir)","description":"A* on a hexagonal grid using cube coordinates (q,r,s where q+r+s=0). 6 neighbor directions instead of 4. Cube distance heuristic: max(abs(dq),abs(dr),abs(ds)). Rich optimization targets: coordinate conversion helpers, 6-way neighbor loop, heuristic with abs/max. Ref: redblobgames.com/grids/hexagons/","status":"open","priority":2,"issue_type":"feature","created_at":"2026-02-13T22:26:20.895841582-05:00","created_by":"phiat","updated_at":"2026-02-13T22:26:20.895841582-05:00"}
{"id":"rrrlz-7x4","title":"Implement Floyd-Warshall all-pairs shortest paths","description":"Floyd-Warshall computes shortest paths between ALL pairs of vertices. O(V^3) with clean triple-nested loop: d[i][j] = min(d[i][j], d[i][k]+d[k][j]). Excellent LLVM target: tight triple loop is prime for loop unrolling, vectorization at O3, cache optimization differences. Simple code, rich optimization surface.","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-02-13T22:26:26.500414886-05:00","created_by":"phiat","updated_at":"2026-02-14T10:20:38.384673595-05:00","closed_at":"2026-02-14T10:20:38.384673595-05:00","close_reason":"Floyd-Warshall implemented with O(V^3) triple loop, all-pairs shortest paths, ALGO.md docs"}
{"id":"rrrlz-98t","title":"Implement IDA* (Iterative Deepening A*)","description":"Memory-efficient A* variant using depth-first search with f-cost threshold. Space: O(d) vs A*'s exponential. Each iteration does cost-bounded DFS, increasing threshold to minimum f-cost that exceeded previous bound. Good LLVM target: recursive DFS, stack-based iteration, threshold comparisons. Interesting contrast to heap-based approaches.","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-02-13T22:26:31.494024644-05:00","created_by":"phiat","updated_at":"2026-02-14T10:20:38.514996069-05:00","closed_at":"2026-02-14T10:20:38.514996069-05:00","close_reason":"IDA* implemented with recursive DFS, f-cost threshold iterative deepening, ALGO.md docs"}
{"id":"rrrlz-99l","title":"Implement Ant Colony Optimization pathfinding","description":"Bio-inspired: simulated ants deposit pheromones on paths, reinforcing good solutions over iterations. Probabilistic path selection based on pheromone intensity + distance heuristic. LLVM interest: heavy floating-point (pheromone decay, probability), randomness, iterative convergence loops, 2D pheromone matrix updates.","status":"open","priority":4,"issue_type":"feature","created_at":"2026-02-13T22:26:45.777057702-05:00","created_by":"phiat","updated_at":"2026-02-13T22:26:45.777057702-05:00"}
{"id":"rrrlz-9x5","title":"Implement flow field pathfinding","description":"Precomputes a vector field directing any position toward a goal. Three phases: cost field, integration field (modified Dijkstra), flow field generation. Used in RTS games (Supreme Commander 2). Great LLVM target: three distinct grid-processing passes, each with different access patterns. Heavy array manipulation.","status":"open","priority":3,"issue_type":"feature","created_at":"2026-02-13T22:26:37.559372905-05:00","created_by":"phiat","updated_at":"2026-02-13T22:26:37.559372905-05:00"}
{"id":"rrrlz-ear","title":"Implement Jump Point Search (JPS) on square grid","description":"JPS prunes symmetric paths in uniform-cost grids by jumping over intermediate nodes. Only expands 'jump points' where direction changes are forced. Same optimality as A* but explores far fewer nodes. Great LLVM target: heavy branching for direction-specific pruning rules, recursive jump functions, forced neighbor detection.","status":"open","priority":2,"issue_type":"feature","created_at":"2026-02-13T22:26:22.37310353-05:00","created_by":"phiat","updated_at":"2026-02-13T22:26:22.37310353-05:00"}
{"id":"rrrlz-iu0","title":"Implement Bellman-Ford shortest path (negative weights)","description":"Bellman-Ford relaxes all edges V-1 times to handle negative edge weights. O(V*E) time. Interesting for LLVM: triple nested loops, edge list iteration, negative cycle detection pass. Different optimization profile from heap-based algorithms - more loop-heavy, less branching.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-02-13T22:26:23.959392165-05:00","created_by":"phiat","updated_at":"2026-02-14T10:20:38.260018488-05:00","closed_at":"2026-02-14T10:20:38.260018488-05:00","close_reason":"Bellman-Ford implemented with edge relaxation, negative cycle detection, ALGO.md docs"}
{"id":"rrrlz-j6w","title":"Build grid pathfinding visualizer (SDL2 on WSLg)","description":"Interactive visualizer for pathfinding algorithms on WSL2 with WSLg (X11 socket at :0, OpenGL available via Mesa). Target: SDL2 + SDL2 software renderer (simplest, no GPU driver issues). Features: render grid, animate node expansion step-by-step, show open/closed sets in color, draw final path, toggle between algorithms, load different maps. Install: apt install libsdl2-dev libsdl2-ttf-dev. Set DISPLAY=:0. Could also support ncurses as fallback (already installed). SDL2 preferred for color/animation quality.","status":"closed","priority":2,"issue_type":"feature","owner":"phiat99@gmail.com","created_at":"2026-02-13T22:33:55.77359735-05:00","created_by":"phiat","updated_at":"2026-02-13T23:07:06.407766334-05:00","closed_at":"2026-02-13T23:07:06.407766334-05:00","close_reason":"SDL2 visualizer implemented: step-through animation for Dijkstra and A* on the 20x20 grid. Supports keyboard controls (Space/Enter/R/1/2/+/-/Q). Builds via build_all.sh or standalone clang+SDL2. Tested on WSLg with DISPLAY=172.31.80.1:0."}
{"id":"rrrlz-jxy","title":"Implement bidirectional A* search","description":"Runs two A* searches simultaneously - forward from start, backward from goal - meeting in the middle. O(b^(d/2)) vs O(b^d). Implementation: two open sets, two closed sets, meeting detection. Good LLVM target: duplicated search logic, interleaved expansion, complex termination condition.","status":"open","priority":3,"issue_type":"feature","created_at":"2026-02-13T22:26:28.461506005-05:00","created_by":"phiat","updated_at":"2026-02-13T22:26:28.461506005-05:00"}
{"id":"rrrlz-yyh","title":"Implement modular algorithm plugin architecture for visualizer","status":"closed","priority":1,"issue_type":"feature","owner":"phiat99@gmail.com","created_at":"2026-02-14T10:42:20.028761181-05:00","created_by":"phiat","updated_at":"2026-02-14T10:46:04.525790602-05:00","closed_at":"2026-02-14T10:46:04.525790602-05:00","close_reason":"Implemented modular plugin architecture: algo.h interface + 5 algorithm step machines (Dijkstra, A*, Bellman-Ford, IDA*, Floyd-Warshall) + refactored visualizer.c"}
